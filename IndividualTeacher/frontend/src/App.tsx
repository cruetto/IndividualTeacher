// frontend/src/App.tsx
import { useState, useEffect, useCallback } from 'react';
import axios from 'axios';
// Import React Router components
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';

import ChatApp from './components/Chat';
import Quiz from './components/Quiz';
import QuizManager from './components/QuizManager';
import QuizCreator from './components/QuizCreator'; // Import the new component
import { QuizData, Question } from './interfaces/interfaces.ts'; // Ensure path is correct

const API_BASE_URL = 'http://localhost:5001'; // Ensure this matches backend

// Assuming using string IDs (UUIDs) generated by backend
type AllUserAnswers = Record<string, number[]>;

function App() {
    const [quizzes, setQuizzes] = useState<QuizData[]>([]);
    const [currentQuizId, setCurrentQuizId] = useState<string | null>(null); // Track by ID
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [allUserAnswers, setAllUserAnswers] = useState<AllUserAnswers>({});

    // Find the current quiz object based on currentQuizId
    const currentQuiz = quizzes.find(q => q.id === currentQuizId);
    // Find answers for the current quiz
    const currentQuizAnswers = currentQuiz ? allUserAnswers[currentQuiz.id] : undefined;

    // Fetch Quizzes Function
    const fetchQuizzes = useCallback(async (selectNewest = false) => { // Flag to select newest after creation
        setLoading(true); // Set loading true when fetching starts
        setError(null);
        let newlyCreatedQuizId: string | null = null; // Store potential new quiz ID

        try {
            console.log(`Fetching quizzes from: ${API_BASE_URL}/api/quizzes`);
            const response = await axios.get<QuizData[]>(`${API_BASE_URL}/api/quizzes`);
            const fetchedQuizzes = response.data || [];
            setQuizzes(fetchedQuizzes); // Update state

            // Determine which quiz ID to select
            if (selectNewest && fetchedQuizzes.length > quizzes.length) {
                // If selecting newest and the list grew, assume the last one is new
                // Note: This assumes ordering or relies on finding the ID if passed back
                newlyCreatedQuizId = fetchedQuizzes[fetchedQuizzes.length - 1]?.id;
            }

            let nextQuizId: string | null = null;
            if (newlyCreatedQuizId) {
                nextQuizId = newlyCreatedQuizId; // Prioritize newly created
            } else if (currentQuizId && fetchedQuizzes.some(q => q.id === currentQuizId)) {
                nextQuizId = currentQuizId; // Keep current if it still exists
            } else if (fetchedQuizzes.length > 0) {
                nextQuizId = fetchedQuizzes[0].id; // Fallback to first
            } else {
                nextQuizId = null; // No quizzes available
            }

            if (nextQuizId) {
                const quizToInit = fetchedQuizzes.find(q => q.id === nextQuizId);
                if (quizToInit) {
                    initializeAnswersForQuiz(quizToInit.id, quizToInit.questions);
                }
            }
            setCurrentQuizId(nextQuizId);

            if (fetchedQuizzes.length === 0) {
                console.warn("No quizzes found.");
            }

        } catch (err) {
            console.error("Error fetching quizzes:", err);
            let message = 'Failed to fetch quizzes.';
            if (axios.isAxiosError(err)) {
                message = err.response?.data?.error || err.message || message;
            } else if (err instanceof Error) {
                message = err.message;
            }
            setError(message);
            setCurrentQuizId(null);
        } finally {
            setLoading(false);
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [currentQuizId]); // Re-fetch might be needed if currentQuizId affects logic indirectly

    // Helper function to initialize answer array
    const initializeAnswersForQuiz = useCallback((quizId: string, questions: Question[]) => {
        setAllUserAnswers(prevAnswers => {
            // Only initialize if not present or length mismatch (needed if quiz content changes)
            if (!prevAnswers[quizId] || prevAnswers[quizId].length !== questions.length) {
                 console.log(`Initializing answers for quiz ${quizId}`);
                return { ...prevAnswers, [quizId]: Array(questions.length).fill(-1) };
            }
            return prevAnswers;
        });
    }, []);

    useEffect(() => {
        fetchQuizzes(); // Fetch on initial mount
    }, [fetchQuizzes]); // fetchQuizzes dependency

    // --- Event Handlers ---
    const handleSelectQuiz = (id: string) => {
        const selected = quizzes.find(quiz => quiz.id === id);
        if (selected) {
            setCurrentQuizId(id);
            initializeAnswersForQuiz(id, selected.questions); // Ensure answers are ready
            console.log("Selected Quiz ID:", id);
        }
    };

    const handleAnswerUpdate = useCallback((quizId: string, questionIndex: number, answerIndex: number) => {
        setAllUserAnswers(prevAnswers => {
            const currentAnswers = prevAnswers[quizId] ? [...prevAnswers[quizId]] : [];
             // Basic bounds check
            if (questionIndex >= 0 && questionIndex < currentAnswers.length) {
                 currentAnswers[questionIndex] = answerIndex;
                 return { ...prevAnswers, [quizId]: currentAnswers };
            }
            console.error("Invalid question index in handleAnswerUpdate");
            return prevAnswers; // Return unchanged state on error
        });
    }, []); // No dependencies needed if only using state setter

    // Callback for when a new quiz is created
    const handleQuizCreated = () => {
        console.log("handleQuizCreated called in App.tsx");
        fetchQuizzes(true); // Refetch the list of quizzes and select the newest (heuristic)
    };

    return (
        <BrowserRouter>
            <>
                 {/* QuizManager rendered outside Routes to be persistent */}
                 <QuizManager
                    quizList={quizzes} // Pass the list of quiz data
                    selectedQuizId={currentQuizId} // Pass current ID for active state
                    onSelectTitleItem={handleSelectQuiz}
                />

                 {/* ChatApp could also be outside Routes if desired */}
                 <ChatApp />

                 {/* Main content area for routes */}
                 <div className="main-content-area" style={{ paddingTop: '5rem', paddingLeft: '1rem', paddingRight: '1rem' }}> {/* Adjust padding */}
                    <Routes>
                        <Route path="/create" element={
                            <QuizCreator onQuizCreated={handleQuizCreated} />
                        } />

                        <Route path="/" element={
                            loading ? <p className='text-center mt-5'>Loading quizzes...</p> :
                            error ? <p className='text-center mt-5' style={{ color: 'red' }}>Error: {error}</p> :
                            currentQuiz && currentQuizAnswers ? (
                                <>
                                    <h1 style={{ textAlign: 'center' }}>{currentQuiz.title}</h1>
                                    <Quiz
                                        // Use a key combining quiz and answer state version if needed,
                                        // but just quiz ID is usually fine if state resets correctly.
                                        key={currentQuiz.id}
                                        quizId={currentQuiz.id}
                                        questions={currentQuiz.questions}
                                        userAnswers={currentQuizAnswers}
                                        onAnswerUpdate={handleAnswerUpdate}
                                    />
                                </>
                            ) : (
                                // Show message if not loading, no error, but also no current quiz selected/available
                                <p className='text-center mt-5'>
                                    {quizzes.length === 0 ? "No quizzes available. Try creating one!" : "Please select a quiz from the manager."}
                                </p>
                            )
                        } />

                        {/* Catch-all or redirect */}
                        <Route path="*" element={<Navigate to="/" replace />} />
                    </Routes>
                 </div>
            </>
        </BrowserRouter>
    );
}

export default App;